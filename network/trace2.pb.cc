// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trace2.proto

#include "trace2.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
#include "google/protobuf/generated_message_tctable_impl.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace trace2 {
        template <typename>
PROTOBUF_CONSTEXPR Body::Body(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.truncated_)*/ false,
      /*decltype(_impl_.body_type_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
    } {}
struct BodyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BodyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BodyDefaultTypeInternal() {}
  union {
    Body _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BodyDefaultTypeInternal _Body_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR SocketAddress::SocketAddress(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.address_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.resolver_name_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.protocol_)*/ 0,
      /*decltype(_impl_.ipv4_compat_)*/ false,
      /*decltype(_impl_.port_specifier_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
    } {}
struct SocketAddressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SocketAddressDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SocketAddressDefaultTypeInternal() {}
  union {
    SocketAddress _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SocketAddressDefaultTypeInternal _SocketAddress_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR Pipe::Pipe(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.path_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.mode_)*/ 0u,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct PipeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PipeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PipeDefaultTypeInternal() {}
  union {
    Pipe _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PipeDefaultTypeInternal _Pipe_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR EnvoyInternalAddress::EnvoyInternalAddress(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.endpoint_id_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.address_name_specifier_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
    } {}
struct EnvoyInternalAddressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EnvoyInternalAddressDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EnvoyInternalAddressDefaultTypeInternal() {}
  union {
    EnvoyInternalAddress _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EnvoyInternalAddressDefaultTypeInternal _EnvoyInternalAddress_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR Address::Address(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.address_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
    } {}
struct AddressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddressDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddressDefaultTypeInternal() {}
  union {
    Address _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddressDefaultTypeInternal _Address_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR Connection::Connection(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.local_address_)*/ nullptr,
      /*decltype(_impl_.remote_address_)*/ nullptr,
    } {}
struct ConnectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionDefaultTypeInternal() {}
  union {
    Connection _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionDefaultTypeInternal _Connection_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR Timestamp::Timestamp(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.seconds_)*/ ::int64_t{0},
      /*decltype(_impl_.nanos_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct TimestampDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TimestampDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TimestampDefaultTypeInternal() {}
  union {
    Timestamp _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TimestampDefaultTypeInternal _Timestamp_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR SocketEvent_Read::SocketEvent_Read(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.data_)*/ nullptr,
    } {}
struct SocketEvent_ReadDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SocketEvent_ReadDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SocketEvent_ReadDefaultTypeInternal() {}
  union {
    SocketEvent_Read _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SocketEvent_ReadDefaultTypeInternal _SocketEvent_Read_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR SocketEvent_Write::SocketEvent_Write(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.data_)*/ nullptr,
      /*decltype(_impl_.end_stream_)*/ false,
    } {}
struct SocketEvent_WriteDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SocketEvent_WriteDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SocketEvent_WriteDefaultTypeInternal() {}
  union {
    SocketEvent_Write _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SocketEvent_WriteDefaultTypeInternal _SocketEvent_Write_default_instance_;
      template <typename>
PROTOBUF_CONSTEXPR SocketEvent_Closed::SocketEvent_Closed(::_pbi::ConstantInitialized) {}
struct SocketEvent_ClosedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SocketEvent_ClosedDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SocketEvent_ClosedDefaultTypeInternal() {}
  union {
    SocketEvent_Closed _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SocketEvent_ClosedDefaultTypeInternal _SocketEvent_Closed_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR SocketEvent::SocketEvent(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.timestamp_)*/ nullptr,
      /*decltype(_impl_.connection_per_event_)*/ nullptr,
      /*decltype(_impl_.event_selector_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
    } {}
struct SocketEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SocketEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SocketEventDefaultTypeInternal() {}
  union {
    SocketEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SocketEventDefaultTypeInternal _SocketEvent_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR SocketBufferedTrace::SocketBufferedTrace(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.events_)*/ {},
      /*decltype(_impl_.connection_)*/ nullptr,
      /*decltype(_impl_.trace_id_)*/ ::uint64_t{0u},
      /*decltype(_impl_.read_truncated_)*/ false,
      /*decltype(_impl_.write_truncated_)*/ false,
    } {}
struct SocketBufferedTraceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SocketBufferedTraceDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SocketBufferedTraceDefaultTypeInternal() {}
  union {
    SocketBufferedTrace _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SocketBufferedTraceDefaultTypeInternal _SocketBufferedTrace_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR SocketStreamedTraceSegment::SocketStreamedTraceSegment(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.trace_id_)*/ ::uint64_t{0u},
      /*decltype(_impl_.message_piece_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
    } {}
struct SocketStreamedTraceSegmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SocketStreamedTraceSegmentDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SocketStreamedTraceSegmentDefaultTypeInternal() {}
  union {
    SocketStreamedTraceSegment _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SocketStreamedTraceSegmentDefaultTypeInternal _SocketStreamedTraceSegment_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR TraceWrapper::TraceWrapper(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.trace_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
    } {}
struct TraceWrapperDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TraceWrapperDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TraceWrapperDefaultTypeInternal() {}
  union {
    TraceWrapper _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TraceWrapperDefaultTypeInternal _TraceWrapper_default_instance_;
}  // namespace trace2
static ::_pb::Metadata file_level_metadata_trace2_2eproto[14];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_trace2_2eproto[1];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_trace2_2eproto = nullptr;
const ::uint32_t TableStruct_trace2_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::trace2::Body, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::trace2::Body, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::trace2::Body, _impl_.truncated_),
    PROTOBUF_FIELD_OFFSET(::trace2::Body, _impl_.body_type_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::trace2::SocketAddress, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::trace2::SocketAddress, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::trace2::SocketAddress, _impl_.protocol_),
    PROTOBUF_FIELD_OFFSET(::trace2::SocketAddress, _impl_.address_),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::trace2::SocketAddress, _impl_.resolver_name_),
    PROTOBUF_FIELD_OFFSET(::trace2::SocketAddress, _impl_.ipv4_compat_),
    PROTOBUF_FIELD_OFFSET(::trace2::SocketAddress, _impl_.port_specifier_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::trace2::Pipe, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::trace2::Pipe, _impl_.path_),
    PROTOBUF_FIELD_OFFSET(::trace2::Pipe, _impl_.mode_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::trace2::EnvoyInternalAddress, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::trace2::EnvoyInternalAddress, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::trace2::EnvoyInternalAddress, _impl_.endpoint_id_),
    PROTOBUF_FIELD_OFFSET(::trace2::EnvoyInternalAddress, _impl_.address_name_specifier_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::trace2::Address, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::trace2::Address, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::trace2::Address, _impl_.address_),
    PROTOBUF_FIELD_OFFSET(::trace2::Connection, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::trace2::Connection, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::trace2::Connection, _impl_.local_address_),
    PROTOBUF_FIELD_OFFSET(::trace2::Connection, _impl_.remote_address_),
    0,
    1,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::trace2::Timestamp, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::trace2::Timestamp, _impl_.seconds_),
    PROTOBUF_FIELD_OFFSET(::trace2::Timestamp, _impl_.nanos_),
    PROTOBUF_FIELD_OFFSET(::trace2::SocketEvent_Read, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::trace2::SocketEvent_Read, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::trace2::SocketEvent_Read, _impl_.data_),
    0,
    PROTOBUF_FIELD_OFFSET(::trace2::SocketEvent_Write, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::trace2::SocketEvent_Write, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::trace2::SocketEvent_Write, _impl_.data_),
    PROTOBUF_FIELD_OFFSET(::trace2::SocketEvent_Write, _impl_.end_stream_),
    0,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::trace2::SocketEvent_Closed, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::trace2::SocketEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::trace2::SocketEvent, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::trace2::SocketEvent, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::trace2::SocketEvent, _impl_.timestamp_),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::trace2::SocketEvent, _impl_.connection_per_event_),
    PROTOBUF_FIELD_OFFSET(::trace2::SocketEvent, _impl_.event_selector_),
    0,
    ~0u,
    ~0u,
    ~0u,
    1,
    PROTOBUF_FIELD_OFFSET(::trace2::SocketBufferedTrace, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::trace2::SocketBufferedTrace, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::trace2::SocketBufferedTrace, _impl_.trace_id_),
    PROTOBUF_FIELD_OFFSET(::trace2::SocketBufferedTrace, _impl_.connection_),
    PROTOBUF_FIELD_OFFSET(::trace2::SocketBufferedTrace, _impl_.events_),
    PROTOBUF_FIELD_OFFSET(::trace2::SocketBufferedTrace, _impl_.read_truncated_),
    PROTOBUF_FIELD_OFFSET(::trace2::SocketBufferedTrace, _impl_.write_truncated_),
    ~0u,
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::trace2::SocketStreamedTraceSegment, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::trace2::SocketStreamedTraceSegment, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::trace2::SocketStreamedTraceSegment, _impl_.trace_id_),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::trace2::SocketStreamedTraceSegment, _impl_.message_piece_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::trace2::TraceWrapper, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::trace2::TraceWrapper, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::trace2::TraceWrapper, _impl_.trace_),
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        {0, -1, -1, sizeof(::trace2::Body)},
        {12, -1, -1, sizeof(::trace2::SocketAddress)},
        {27, -1, -1, sizeof(::trace2::Pipe)},
        {37, -1, -1, sizeof(::trace2::EnvoyInternalAddress)},
        {48, -1, -1, sizeof(::trace2::Address)},
        {60, 70, -1, sizeof(::trace2::Connection)},
        {72, -1, -1, sizeof(::trace2::Timestamp)},
        {82, 91, -1, sizeof(::trace2::SocketEvent_Read)},
        {92, 102, -1, sizeof(::trace2::SocketEvent_Write)},
        {104, -1, -1, sizeof(::trace2::SocketEvent_Closed)},
        {112, 126, -1, sizeof(::trace2::SocketEvent)},
        {131, 144, -1, sizeof(::trace2::SocketBufferedTrace)},
        {149, -1, -1, sizeof(::trace2::SocketStreamedTraceSegment)},
        {161, -1, -1, sizeof(::trace2::TraceWrapper)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::trace2::_Body_default_instance_._instance,
    &::trace2::_SocketAddress_default_instance_._instance,
    &::trace2::_Pipe_default_instance_._instance,
    &::trace2::_EnvoyInternalAddress_default_instance_._instance,
    &::trace2::_Address_default_instance_._instance,
    &::trace2::_Connection_default_instance_._instance,
    &::trace2::_Timestamp_default_instance_._instance,
    &::trace2::_SocketEvent_Read_default_instance_._instance,
    &::trace2::_SocketEvent_Write_default_instance_._instance,
    &::trace2::_SocketEvent_Closed_default_instance_._instance,
    &::trace2::_SocketEvent_default_instance_._instance,
    &::trace2::_SocketBufferedTrace_default_instance_._instance,
    &::trace2::_SocketStreamedTraceSegment_default_instance_._instance,
    &::trace2::_TraceWrapper_default_instance_._instance,
};
const char descriptor_table_protodef_trace2_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\014trace2.proto\022\006trace2\"O\n\004Body\022\022\n\010as_byt"
    "es\030\001 \001(\014H\000\022\023\n\tas_string\030\002 \001(\tH\000\022\021\n\ttrunc"
    "ated\030\003 \001(\010B\013\n\tbody_type\"\332\001\n\rSocketAddres"
    "s\0220\n\010protocol\030\001 \001(\0162\036.trace2.SocketAddre"
    "ss.Protocol\022\017\n\007address\030\002 \001(\t\022\024\n\nport_val"
    "ue\030\003 \001(\rH\000\022\024\n\nnamed_port\030\004 \001(\tH\000\022\025\n\rreso"
    "lver_name\030\005 \001(\t\022\023\n\013ipv4_compat\030\006 \001(\010\"\034\n\010"
    "Protocol\022\007\n\003TCP\020\000\022\007\n\003UDP\020\001B\020\n\016port_speci"
    "fier\"\"\n\004Pipe\022\014\n\004path\030\001 \001(\t\022\014\n\004mode\030\002 \001(\r"
    "\"e\n\024EnvoyInternalAddress\022\036\n\024server_liste"
    "ner_name\030\001 \001(\tH\000\022\023\n\013endpoint_id\030\002 \001(\tB\030\n"
    "\026address_name_specifier\"\243\001\n\007Address\022/\n\016s"
    "ocket_address\030\001 \001(\0132\025.trace2.SocketAddre"
    "ssH\000\022\034\n\004pipe\030\002 \001(\0132\014.trace2.PipeH\000\022>\n\026en"
    "voy_internal_address\030\003 \001(\0132\034.trace2.Envo"
    "yInternalAddressH\000B\t\n\007address\"]\n\nConnect"
    "ion\022&\n\rlocal_address\030\001 \001(\0132\017.trace2.Addr"
    "ess\022\'\n\016remote_address\030\002 \001(\0132\017.trace2.Add"
    "ress\"+\n\tTimestamp\022\017\n\007seconds\030\001 \001(\003\022\r\n\005na"
    "nos\030\002 \001(\005\"\342\002\n\013SocketEvent\022$\n\ttimestamp\030\001"
    " \001(\0132\021.trace2.Timestamp\022(\n\004read\030\002 \001(\0132\030."
    "trace2.SocketEvent.ReadH\000\022*\n\005write\030\003 \001(\013"
    "2\031.trace2.SocketEvent.WriteH\000\022,\n\006closed\030"
    "\004 \001(\0132\032.trace2.SocketEvent.ClosedH\000\0220\n\024c"
    "onnection_per_event\030\005 \001(\0132\022.trace2.Conne"
    "ction\032\"\n\004Read\022\032\n\004data\030\001 \001(\0132\014.trace2.Bod"
    "y\0327\n\005Write\022\032\n\004data\030\001 \001(\0132\014.trace2.Body\022\022"
    "\n\nend_stream\030\002 \001(\010\032\010\n\006ClosedB\020\n\016event_se"
    "lector\"\245\001\n\023SocketBufferedTrace\022\020\n\010trace_"
    "id\030\001 \001(\004\022&\n\nconnection\030\002 \001(\0132\022.trace2.Co"
    "nnection\022#\n\006events\030\003 \003(\0132\023.trace2.Socket"
    "Event\022\026\n\016read_truncated\030\004 \001(\010\022\027\n\017write_t"
    "runcated\030\005 \001(\010\"\217\001\n\032SocketStreamedTraceSe"
    "gment\022\020\n\010trace_id\030\001 \001(\004\022(\n\nconnection\030\002 "
    "\001(\0132\022.trace2.ConnectionH\000\022$\n\005event\030\003 \001(\013"
    "2\023.trace2.SocketEventH\000B\017\n\rmessage_piece"
    "\"\242\001\n\014TraceWrapper\022<\n\025socket_buffered_tra"
    "ce\030\003 \001(\0132\033.trace2.SocketBufferedTraceH\000\022"
    "K\n\035socket_streamed_trace_segment\030\004 \001(\0132\""
    ".trace2.SocketStreamedTraceSegmentH\000B\007\n\005"
    "traceb\006proto3"
};
static ::absl::once_flag descriptor_table_trace2_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_trace2_2eproto = {
    false,
    false,
    1613,
    descriptor_table_protodef_trace2_2eproto,
    "trace2.proto",
    &descriptor_table_trace2_2eproto_once,
    nullptr,
    0,
    14,
    schemas,
    file_default_instances,
    TableStruct_trace2_2eproto::offsets,
    file_level_metadata_trace2_2eproto,
    file_level_enum_descriptors_trace2_2eproto,
    file_level_service_descriptors_trace2_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_trace2_2eproto_getter() {
  return &descriptor_table_trace2_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_trace2_2eproto(&descriptor_table_trace2_2eproto);
namespace trace2 {
const ::google::protobuf::EnumDescriptor* SocketAddress_Protocol_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_trace2_2eproto);
  return file_level_enum_descriptors_trace2_2eproto[0];
}
bool SocketAddress_Protocol_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr SocketAddress_Protocol SocketAddress::TCP;
constexpr SocketAddress_Protocol SocketAddress::UDP;
constexpr SocketAddress_Protocol SocketAddress::Protocol_MIN;
constexpr SocketAddress_Protocol SocketAddress::Protocol_MAX;
constexpr int SocketAddress::Protocol_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
// ===================================================================

class Body::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::trace2::Body, _impl_._oneof_case_);
};

Body::Body(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:trace2.Body)
}
Body::Body(const Body& from) : ::google::protobuf::Message() {
  Body* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.truncated_){},
      decltype(_impl_.body_type_){},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _this->_impl_.truncated_ = from._impl_.truncated_;
  clear_has_body_type();
  switch (from.body_type_case()) {
    case kAsBytes: {
      _this->_internal_set_as_bytes(from._internal_as_bytes());
      break;
    }
    case kAsString: {
      _this->_internal_set_as_string(from._internal_as_string());
      break;
    }
    case BODY_TYPE_NOT_SET: {
      break;
    }
  }

  // @@protoc_insertion_point(copy_constructor:trace2.Body)
}
inline void Body::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.truncated_){false},
      decltype(_impl_.body_type_){},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  clear_has_body_type();
}
Body::~Body() {
  // @@protoc_insertion_point(destructor:trace2.Body)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Body::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_body_type()) {
    clear_body_type();
  }
}
void Body::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Body::clear_body_type() {
// @@protoc_insertion_point(one_of_clear_start:trace2.Body)
  switch (body_type_case()) {
    case kAsBytes: {
      _impl_.body_type_.as_bytes_.Destroy();
      break;
    }
    case kAsString: {
      _impl_.body_type_.as_string_.Destroy();
      break;
    }
    case BODY_TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = BODY_TYPE_NOT_SET;
}


PROTOBUF_NOINLINE void Body::Clear() {
// @@protoc_insertion_point(message_clear_start:trace2.Body)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.truncated_ = false;
  clear_body_type();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Body::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 3, 0, 29, 2> Body::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_Body_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // bool truncated = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Body, _impl_.truncated_), 63>(),
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(Body, _impl_.truncated_)}},
  }}, {{
    65535, 65535
  }}, {{
    // bytes as_bytes = 1;
    {PROTOBUF_FIELD_OFFSET(Body, _impl_.body_type_.as_bytes_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBytes | ::_fl::kRepAString)},
    // string as_string = 2;
    {PROTOBUF_FIELD_OFFSET(Body, _impl_.body_type_.as_string_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // bool truncated = 3;
    {PROTOBUF_FIELD_OFFSET(Body, _impl_.truncated_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
    "\13\0\11\0\0\0\0\0"
    "trace2.Body"
    "as_string"
  }},
};

::uint8_t* Body::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:trace2.Body)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  switch (body_type_case()) {
    case kAsBytes: {
      const std::string& _s = this->_internal_as_bytes();
      target = stream->WriteBytesMaybeAliased(1, _s, target);
      break;
    }
    case kAsString: {
      const std::string& _s = this->_internal_as_string();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "trace2.Body.as_string");
      target = stream->WriteStringMaybeAliased(2, _s, target);
      break;
    }
    default:
      break;
  }
  // bool truncated = 3;
  if (this->_internal_truncated() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_truncated(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trace2.Body)
  return target;
}

::size_t Body::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trace2.Body)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool truncated = 3;
  if (this->_internal_truncated() != 0) {
    total_size += 2;
  }

  switch (body_type_case()) {
    // bytes as_bytes = 1;
    case kAsBytes: {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_as_bytes());
      break;
    }
    // string as_string = 2;
    case kAsString: {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_as_string());
      break;
    }
    case BODY_TYPE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Body::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    Body::MergeImpl
};
const ::google::protobuf::Message::ClassData*Body::GetClassData() const { return &_class_data_; }


void Body::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Body*>(&to_msg);
  auto& from = static_cast<const Body&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:trace2.Body)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_truncated() != 0) {
    _this->_internal_set_truncated(from._internal_truncated());
  }
  switch (from.body_type_case()) {
    case kAsBytes: {
      _this->_internal_set_as_bytes(from._internal_as_bytes());
      break;
    }
    case kAsString: {
      _this->_internal_set_as_string(from._internal_as_string());
      break;
    }
    case BODY_TYPE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Body::CopyFrom(const Body& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trace2.Body)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Body::IsInitialized() const {
  return true;
}

void Body::InternalSwap(Body* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
        swap(_impl_.truncated_, other->_impl_.truncated_);
  swap(_impl_.body_type_, other->_impl_.body_type_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata Body::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_trace2_2eproto_getter, &descriptor_table_trace2_2eproto_once,
      file_level_metadata_trace2_2eproto[0]);
}
// ===================================================================

class SocketAddress::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::trace2::SocketAddress, _impl_._oneof_case_);
};

SocketAddress::SocketAddress(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:trace2.SocketAddress)
}
SocketAddress::SocketAddress(const SocketAddress& from) : ::google::protobuf::Message() {
  SocketAddress* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.address_){},
      decltype(_impl_.resolver_name_){},
      decltype(_impl_.protocol_){},
      decltype(_impl_.ipv4_compat_){},
      decltype(_impl_.port_specifier_){},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_address().empty()) {
    _this->_impl_.address_.Set(from._internal_address(), _this->GetArenaForAllocation());
  }
  _impl_.resolver_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.resolver_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_resolver_name().empty()) {
    _this->_impl_.resolver_name_.Set(from._internal_resolver_name(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.protocol_, &from._impl_.protocol_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.ipv4_compat_) -
    reinterpret_cast<char*>(&_impl_.protocol_)) + sizeof(_impl_.ipv4_compat_));
  clear_has_port_specifier();
  switch (from.port_specifier_case()) {
    case kPortValue: {
      _this->_internal_set_port_value(from._internal_port_value());
      break;
    }
    case kNamedPort: {
      _this->_internal_set_named_port(from._internal_named_port());
      break;
    }
    case PORT_SPECIFIER_NOT_SET: {
      break;
    }
  }

  // @@protoc_insertion_point(copy_constructor:trace2.SocketAddress)
}
inline void SocketAddress::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.address_){},
      decltype(_impl_.resolver_name_){},
      decltype(_impl_.protocol_){0},
      decltype(_impl_.ipv4_compat_){false},
      decltype(_impl_.port_specifier_){},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.resolver_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.resolver_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_port_specifier();
}
SocketAddress::~SocketAddress() {
  // @@protoc_insertion_point(destructor:trace2.SocketAddress)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SocketAddress::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.address_.Destroy();
  _impl_.resolver_name_.Destroy();
  if (has_port_specifier()) {
    clear_port_specifier();
  }
}
void SocketAddress::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SocketAddress::clear_port_specifier() {
// @@protoc_insertion_point(one_of_clear_start:trace2.SocketAddress)
  switch (port_specifier_case()) {
    case kPortValue: {
      // No need to clear
      break;
    }
    case kNamedPort: {
      _impl_.port_specifier_.named_port_.Destroy();
      break;
    }
    case PORT_SPECIFIER_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PORT_SPECIFIER_NOT_SET;
}


PROTOBUF_NOINLINE void SocketAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:trace2.SocketAddress)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.address_.ClearToEmpty();
  _impl_.resolver_name_.ClearToEmpty();
  ::memset(&_impl_.protocol_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.ipv4_compat_) -
      reinterpret_cast<char*>(&_impl_.protocol_)) + sizeof(_impl_.ipv4_compat_));
  clear_port_specifier();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* SocketAddress::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 0, 59, 2> SocketAddress::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_SocketAddress_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .trace2.SocketAddress.Protocol protocol = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(SocketAddress, _impl_.protocol_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(SocketAddress, _impl_.protocol_)}},
    // string address = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(SocketAddress, _impl_.address_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // string resolver_name = 5;
    {::_pbi::TcParser::FastUS1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(SocketAddress, _impl_.resolver_name_)}},
    // bool ipv4_compat = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(SocketAddress, _impl_.ipv4_compat_), 63>(),
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(SocketAddress, _impl_.ipv4_compat_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // .trace2.SocketAddress.Protocol protocol = 1;
    {PROTOBUF_FIELD_OFFSET(SocketAddress, _impl_.protocol_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // string address = 2;
    {PROTOBUF_FIELD_OFFSET(SocketAddress, _impl_.address_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // uint32 port_value = 3;
    {PROTOBUF_FIELD_OFFSET(SocketAddress, _impl_.port_specifier_.port_value_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // string named_port = 4;
    {PROTOBUF_FIELD_OFFSET(SocketAddress, _impl_.port_specifier_.named_port_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string resolver_name = 5;
    {PROTOBUF_FIELD_OFFSET(SocketAddress, _impl_.resolver_name_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // bool ipv4_compat = 6;
    {PROTOBUF_FIELD_OFFSET(SocketAddress, _impl_.ipv4_compat_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
    "\24\0\7\0\12\15\0\0"
    "trace2.SocketAddress"
    "address"
    "named_port"
    "resolver_name"
  }},
};

::uint8_t* SocketAddress::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:trace2.SocketAddress)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // .trace2.SocketAddress.Protocol protocol = 1;
  if (this->_internal_protocol() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_protocol(), target);
  }

  // string address = 2;
  if (!this->_internal_address().empty()) {
    const std::string& _s = this->_internal_address();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "trace2.SocketAddress.address");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  switch (port_specifier_case()) {
    case kPortValue: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          3, this->_internal_port_value(), target);
      break;
    }
    case kNamedPort: {
      const std::string& _s = this->_internal_named_port();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "trace2.SocketAddress.named_port");
      target = stream->WriteStringMaybeAliased(4, _s, target);
      break;
    }
    default:
      break;
  }
  // string resolver_name = 5;
  if (!this->_internal_resolver_name().empty()) {
    const std::string& _s = this->_internal_resolver_name();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "trace2.SocketAddress.resolver_name");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // bool ipv4_compat = 6;
  if (this->_internal_ipv4_compat() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        6, this->_internal_ipv4_compat(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trace2.SocketAddress)
  return target;
}

::size_t SocketAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trace2.SocketAddress)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string address = 2;
  if (!this->_internal_address().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_address());
  }

  // string resolver_name = 5;
  if (!this->_internal_resolver_name().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_resolver_name());
  }

  // .trace2.SocketAddress.Protocol protocol = 1;
  if (this->_internal_protocol() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_protocol());
  }

  // bool ipv4_compat = 6;
  if (this->_internal_ipv4_compat() != 0) {
    total_size += 2;
  }

  switch (port_specifier_case()) {
    // uint32 port_value = 3;
    case kPortValue: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_port_value());
      break;
    }
    // string named_port = 4;
    case kNamedPort: {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_named_port());
      break;
    }
    case PORT_SPECIFIER_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData SocketAddress::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    SocketAddress::MergeImpl
};
const ::google::protobuf::Message::ClassData*SocketAddress::GetClassData() const { return &_class_data_; }


void SocketAddress::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<SocketAddress*>(&to_msg);
  auto& from = static_cast<const SocketAddress&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:trace2.SocketAddress)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_address().empty()) {
    _this->_internal_set_address(from._internal_address());
  }
  if (!from._internal_resolver_name().empty()) {
    _this->_internal_set_resolver_name(from._internal_resolver_name());
  }
  if (from._internal_protocol() != 0) {
    _this->_internal_set_protocol(from._internal_protocol());
  }
  if (from._internal_ipv4_compat() != 0) {
    _this->_internal_set_ipv4_compat(from._internal_ipv4_compat());
  }
  switch (from.port_specifier_case()) {
    case kPortValue: {
      _this->_internal_set_port_value(from._internal_port_value());
      break;
    }
    case kNamedPort: {
      _this->_internal_set_named_port(from._internal_named_port());
      break;
    }
    case PORT_SPECIFIER_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SocketAddress::CopyFrom(const SocketAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trace2.SocketAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SocketAddress::IsInitialized() const {
  return true;
}

void SocketAddress::InternalSwap(SocketAddress* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.address_, lhs_arena,
                                       &other->_impl_.address_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.resolver_name_, lhs_arena,
                                       &other->_impl_.resolver_name_, rhs_arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SocketAddress, _impl_.ipv4_compat_)
      + sizeof(SocketAddress::_impl_.ipv4_compat_)
      - PROTOBUF_FIELD_OFFSET(SocketAddress, _impl_.protocol_)>(
          reinterpret_cast<char*>(&_impl_.protocol_),
          reinterpret_cast<char*>(&other->_impl_.protocol_));
  swap(_impl_.port_specifier_, other->_impl_.port_specifier_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata SocketAddress::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_trace2_2eproto_getter, &descriptor_table_trace2_2eproto_once,
      file_level_metadata_trace2_2eproto[1]);
}
// ===================================================================

class Pipe::_Internal {
 public:
};

Pipe::Pipe(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:trace2.Pipe)
}
Pipe::Pipe(const Pipe& from) : ::google::protobuf::Message() {
  Pipe* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){},
      decltype(_impl_.mode_){},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.path_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_path().empty()) {
    _this->_impl_.path_.Set(from._internal_path(), _this->GetArenaForAllocation());
  }
  _this->_impl_.mode_ = from._impl_.mode_;

  // @@protoc_insertion_point(copy_constructor:trace2.Pipe)
}
inline void Pipe::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){},
      decltype(_impl_.mode_){0u},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.path_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
Pipe::~Pipe() {
  // @@protoc_insertion_point(destructor:trace2.Pipe)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Pipe::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.path_.Destroy();
}
void Pipe::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void Pipe::Clear() {
// @@protoc_insertion_point(message_clear_start:trace2.Pipe)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.path_.ClearToEmpty();
  _impl_.mode_ = 0u;
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Pipe::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 24, 2> Pipe::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_Pipe_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // uint32 mode = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Pipe, _impl_.mode_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(Pipe, _impl_.mode_)}},
    // string path = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(Pipe, _impl_.path_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string path = 1;
    {PROTOBUF_FIELD_OFFSET(Pipe, _impl_.path_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // uint32 mode = 2;
    {PROTOBUF_FIELD_OFFSET(Pipe, _impl_.mode_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
    "\13\4\0\0\0\0\0\0"
    "trace2.Pipe"
    "path"
  }},
};

::uint8_t* Pipe::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:trace2.Pipe)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string path = 1;
  if (!this->_internal_path().empty()) {
    const std::string& _s = this->_internal_path();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "trace2.Pipe.path");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // uint32 mode = 2;
  if (this->_internal_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trace2.Pipe)
  return target;
}

::size_t Pipe::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trace2.Pipe)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string path = 1;
  if (!this->_internal_path().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_path());
  }

  // uint32 mode = 2;
  if (this->_internal_mode() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_mode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Pipe::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    Pipe::MergeImpl
};
const ::google::protobuf::Message::ClassData*Pipe::GetClassData() const { return &_class_data_; }


void Pipe::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Pipe*>(&to_msg);
  auto& from = static_cast<const Pipe&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:trace2.Pipe)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_path().empty()) {
    _this->_internal_set_path(from._internal_path());
  }
  if (from._internal_mode() != 0) {
    _this->_internal_set_mode(from._internal_mode());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Pipe::CopyFrom(const Pipe& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trace2.Pipe)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Pipe::IsInitialized() const {
  return true;
}

void Pipe::InternalSwap(Pipe* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.path_, lhs_arena,
                                       &other->_impl_.path_, rhs_arena);
        swap(_impl_.mode_, other->_impl_.mode_);
}

::google::protobuf::Metadata Pipe::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_trace2_2eproto_getter, &descriptor_table_trace2_2eproto_once,
      file_level_metadata_trace2_2eproto[2]);
}
// ===================================================================

class EnvoyInternalAddress::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::trace2::EnvoyInternalAddress, _impl_._oneof_case_);
};

EnvoyInternalAddress::EnvoyInternalAddress(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:trace2.EnvoyInternalAddress)
}
EnvoyInternalAddress::EnvoyInternalAddress(const EnvoyInternalAddress& from) : ::google::protobuf::Message() {
  EnvoyInternalAddress* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.endpoint_id_){},
      decltype(_impl_.address_name_specifier_){},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.endpoint_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.endpoint_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_endpoint_id().empty()) {
    _this->_impl_.endpoint_id_.Set(from._internal_endpoint_id(), _this->GetArenaForAllocation());
  }
  clear_has_address_name_specifier();
  switch (from.address_name_specifier_case()) {
    case kServerListenerName: {
      _this->_internal_set_server_listener_name(from._internal_server_listener_name());
      break;
    }
    case ADDRESS_NAME_SPECIFIER_NOT_SET: {
      break;
    }
  }

  // @@protoc_insertion_point(copy_constructor:trace2.EnvoyInternalAddress)
}
inline void EnvoyInternalAddress::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.endpoint_id_){},
      decltype(_impl_.address_name_specifier_){},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _impl_.endpoint_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.endpoint_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_address_name_specifier();
}
EnvoyInternalAddress::~EnvoyInternalAddress() {
  // @@protoc_insertion_point(destructor:trace2.EnvoyInternalAddress)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void EnvoyInternalAddress::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.endpoint_id_.Destroy();
  if (has_address_name_specifier()) {
    clear_address_name_specifier();
  }
}
void EnvoyInternalAddress::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EnvoyInternalAddress::clear_address_name_specifier() {
// @@protoc_insertion_point(one_of_clear_start:trace2.EnvoyInternalAddress)
  switch (address_name_specifier_case()) {
    case kServerListenerName: {
      _impl_.address_name_specifier_.server_listener_name_.Destroy();
      break;
    }
    case ADDRESS_NAME_SPECIFIER_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ADDRESS_NAME_SPECIFIER_NOT_SET;
}


PROTOBUF_NOINLINE void EnvoyInternalAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:trace2.EnvoyInternalAddress)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.endpoint_id_.ClearToEmpty();
  clear_address_name_specifier();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* EnvoyInternalAddress::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 2, 0, 67, 2> EnvoyInternalAddress::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_EnvoyInternalAddress_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // string endpoint_id = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(EnvoyInternalAddress, _impl_.endpoint_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string server_listener_name = 1;
    {PROTOBUF_FIELD_OFFSET(EnvoyInternalAddress, _impl_.address_name_specifier_.server_listener_name_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string endpoint_id = 2;
    {PROTOBUF_FIELD_OFFSET(EnvoyInternalAddress, _impl_.endpoint_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\33\24\13\0\0\0\0\0"
    "trace2.EnvoyInternalAddress"
    "server_listener_name"
    "endpoint_id"
  }},
};

::uint8_t* EnvoyInternalAddress::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:trace2.EnvoyInternalAddress)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string server_listener_name = 1;
  if (address_name_specifier_case() == kServerListenerName) {
    const std::string& _s = this->_internal_server_listener_name();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "trace2.EnvoyInternalAddress.server_listener_name");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string endpoint_id = 2;
  if (!this->_internal_endpoint_id().empty()) {
    const std::string& _s = this->_internal_endpoint_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "trace2.EnvoyInternalAddress.endpoint_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trace2.EnvoyInternalAddress)
  return target;
}

::size_t EnvoyInternalAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trace2.EnvoyInternalAddress)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string endpoint_id = 2;
  if (!this->_internal_endpoint_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_endpoint_id());
  }

  switch (address_name_specifier_case()) {
    // string server_listener_name = 1;
    case kServerListenerName: {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_server_listener_name());
      break;
    }
    case ADDRESS_NAME_SPECIFIER_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData EnvoyInternalAddress::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    EnvoyInternalAddress::MergeImpl
};
const ::google::protobuf::Message::ClassData*EnvoyInternalAddress::GetClassData() const { return &_class_data_; }


void EnvoyInternalAddress::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<EnvoyInternalAddress*>(&to_msg);
  auto& from = static_cast<const EnvoyInternalAddress&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:trace2.EnvoyInternalAddress)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_endpoint_id().empty()) {
    _this->_internal_set_endpoint_id(from._internal_endpoint_id());
  }
  switch (from.address_name_specifier_case()) {
    case kServerListenerName: {
      _this->_internal_set_server_listener_name(from._internal_server_listener_name());
      break;
    }
    case ADDRESS_NAME_SPECIFIER_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void EnvoyInternalAddress::CopyFrom(const EnvoyInternalAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trace2.EnvoyInternalAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool EnvoyInternalAddress::IsInitialized() const {
  return true;
}

void EnvoyInternalAddress::InternalSwap(EnvoyInternalAddress* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.endpoint_id_, lhs_arena,
                                       &other->_impl_.endpoint_id_, rhs_arena);
  swap(_impl_.address_name_specifier_, other->_impl_.address_name_specifier_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata EnvoyInternalAddress::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_trace2_2eproto_getter, &descriptor_table_trace2_2eproto_once,
      file_level_metadata_trace2_2eproto[3]);
}
// ===================================================================

class Address::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::trace2::Address, _impl_._oneof_case_);
  static const ::trace2::SocketAddress& socket_address(const Address* msg);
  static const ::trace2::Pipe& pipe(const Address* msg);
  static const ::trace2::EnvoyInternalAddress& envoy_internal_address(const Address* msg);
};

const ::trace2::SocketAddress& Address::_Internal::socket_address(const Address* msg) {
  return *msg->_impl_.address_.socket_address_;
}
const ::trace2::Pipe& Address::_Internal::pipe(const Address* msg) {
  return *msg->_impl_.address_.pipe_;
}
const ::trace2::EnvoyInternalAddress& Address::_Internal::envoy_internal_address(const Address* msg) {
  return *msg->_impl_.address_.envoy_internal_address_;
}
void Address::set_allocated_socket_address(::trace2::SocketAddress* socket_address) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_address();
  if (socket_address) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(socket_address);
    if (message_arena != submessage_arena) {
      socket_address = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, socket_address, submessage_arena);
    }
    set_has_socket_address();
    _impl_.address_.socket_address_ = socket_address;
  }
  // @@protoc_insertion_point(field_set_allocated:trace2.Address.socket_address)
}
void Address::set_allocated_pipe(::trace2::Pipe* pipe) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_address();
  if (pipe) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(pipe);
    if (message_arena != submessage_arena) {
      pipe = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pipe, submessage_arena);
    }
    set_has_pipe();
    _impl_.address_.pipe_ = pipe;
  }
  // @@protoc_insertion_point(field_set_allocated:trace2.Address.pipe)
}
void Address::set_allocated_envoy_internal_address(::trace2::EnvoyInternalAddress* envoy_internal_address) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_address();
  if (envoy_internal_address) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(envoy_internal_address);
    if (message_arena != submessage_arena) {
      envoy_internal_address = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, envoy_internal_address, submessage_arena);
    }
    set_has_envoy_internal_address();
    _impl_.address_.envoy_internal_address_ = envoy_internal_address;
  }
  // @@protoc_insertion_point(field_set_allocated:trace2.Address.envoy_internal_address)
}
Address::Address(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:trace2.Address)
}
Address::Address(const Address& from) : ::google::protobuf::Message() {
  Address* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.address_){},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  clear_has_address();
  switch (from.address_case()) {
    case kSocketAddress: {
      _this->_internal_mutable_socket_address()->::trace2::SocketAddress::MergeFrom(
          from._internal_socket_address());
      break;
    }
    case kPipe: {
      _this->_internal_mutable_pipe()->::trace2::Pipe::MergeFrom(
          from._internal_pipe());
      break;
    }
    case kEnvoyInternalAddress: {
      _this->_internal_mutable_envoy_internal_address()->::trace2::EnvoyInternalAddress::MergeFrom(
          from._internal_envoy_internal_address());
      break;
    }
    case ADDRESS_NOT_SET: {
      break;
    }
  }

  // @@protoc_insertion_point(copy_constructor:trace2.Address)
}
inline void Address::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.address_){},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  clear_has_address();
}
Address::~Address() {
  // @@protoc_insertion_point(destructor:trace2.Address)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Address::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_address()) {
    clear_address();
  }
}
void Address::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Address::clear_address() {
// @@protoc_insertion_point(one_of_clear_start:trace2.Address)
  switch (address_case()) {
    case kSocketAddress: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.address_.socket_address_;
      }
      break;
    }
    case kPipe: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.address_.pipe_;
      }
      break;
    }
    case kEnvoyInternalAddress: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.address_.envoy_internal_address_;
      }
      break;
    }
    case ADDRESS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ADDRESS_NOT_SET;
}


PROTOBUF_NOINLINE void Address::Clear() {
// @@protoc_insertion_point(message_clear_start:trace2.Address)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_address();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Address::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 3, 3, 0, 2> Address::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_Address_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // .trace2.SocketAddress socket_address = 1;
    {PROTOBUF_FIELD_OFFSET(Address, _impl_.address_.socket_address_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .trace2.Pipe pipe = 2;
    {PROTOBUF_FIELD_OFFSET(Address, _impl_.address_.pipe_), _Internal::kOneofCaseOffset + 0, 1,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .trace2.EnvoyInternalAddress envoy_internal_address = 3;
    {PROTOBUF_FIELD_OFFSET(Address, _impl_.address_.envoy_internal_address_), _Internal::kOneofCaseOffset + 0, 2,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::trace2::SocketAddress>()},
    {::_pbi::TcParser::GetTable<::trace2::Pipe>()},
    {::_pbi::TcParser::GetTable<::trace2::EnvoyInternalAddress>()},
  }}, {{
  }},
};

::uint8_t* Address::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:trace2.Address)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  switch (address_case()) {
    case kSocketAddress: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::socket_address(this),
          _Internal::socket_address(this).GetCachedSize(), target, stream);
      break;
    }
    case kPipe: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::pipe(this),
          _Internal::pipe(this).GetCachedSize(), target, stream);
      break;
    }
    case kEnvoyInternalAddress: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::envoy_internal_address(this),
          _Internal::envoy_internal_address(this).GetCachedSize(), target, stream);
      break;
    }
    default:
      break;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trace2.Address)
  return target;
}

::size_t Address::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trace2.Address)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (address_case()) {
    // .trace2.SocketAddress socket_address = 1;
    case kSocketAddress: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.address_.socket_address_);
      break;
    }
    // .trace2.Pipe pipe = 2;
    case kPipe: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.address_.pipe_);
      break;
    }
    // .trace2.EnvoyInternalAddress envoy_internal_address = 3;
    case kEnvoyInternalAddress: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.address_.envoy_internal_address_);
      break;
    }
    case ADDRESS_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Address::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    Address::MergeImpl
};
const ::google::protobuf::Message::ClassData*Address::GetClassData() const { return &_class_data_; }


void Address::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Address*>(&to_msg);
  auto& from = static_cast<const Address&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:trace2.Address)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.address_case()) {
    case kSocketAddress: {
      _this->_internal_mutable_socket_address()->::trace2::SocketAddress::MergeFrom(
          from._internal_socket_address());
      break;
    }
    case kPipe: {
      _this->_internal_mutable_pipe()->::trace2::Pipe::MergeFrom(
          from._internal_pipe());
      break;
    }
    case kEnvoyInternalAddress: {
      _this->_internal_mutable_envoy_internal_address()->::trace2::EnvoyInternalAddress::MergeFrom(
          from._internal_envoy_internal_address());
      break;
    }
    case ADDRESS_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Address::CopyFrom(const Address& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trace2.Address)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Address::IsInitialized() const {
  return true;
}

void Address::InternalSwap(Address* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.address_, other->_impl_.address_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata Address::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_trace2_2eproto_getter, &descriptor_table_trace2_2eproto_once,
      file_level_metadata_trace2_2eproto[4]);
}
// ===================================================================

class Connection::_Internal {
 public:
  using HasBits = decltype(std::declval<Connection>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Connection, _impl_._has_bits_);
  static const ::trace2::Address& local_address(const Connection* msg);
  static void set_has_local_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::trace2::Address& remote_address(const Connection* msg);
  static void set_has_remote_address(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::trace2::Address& Connection::_Internal::local_address(const Connection* msg) {
  return *msg->_impl_.local_address_;
}
const ::trace2::Address& Connection::_Internal::remote_address(const Connection* msg) {
  return *msg->_impl_.remote_address_;
}
Connection::Connection(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:trace2.Connection)
}
Connection::Connection(const Connection& from) : ::google::protobuf::Message() {
  Connection* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.local_address_){nullptr},
      decltype(_impl_.remote_address_){nullptr},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.local_address_ = new ::trace2::Address(*from._impl_.local_address_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.remote_address_ = new ::trace2::Address(*from._impl_.remote_address_);
  }

  // @@protoc_insertion_point(copy_constructor:trace2.Connection)
}
inline void Connection::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.local_address_){nullptr},
      decltype(_impl_.remote_address_){nullptr},
  };
}
Connection::~Connection() {
  // @@protoc_insertion_point(destructor:trace2.Connection)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Connection::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.local_address_;
  if (this != internal_default_instance()) delete _impl_.remote_address_;
}
void Connection::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void Connection::Clear() {
// @@protoc_insertion_point(message_clear_start:trace2.Connection)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.local_address_ != nullptr);
      _impl_.local_address_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.remote_address_ != nullptr);
      _impl_.remote_address_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Connection::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 2, 0, 2> Connection::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Connection, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_Connection_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // .trace2.Address remote_address = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(Connection, _impl_.remote_address_)}},
    // .trace2.Address local_address = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(Connection, _impl_.local_address_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .trace2.Address local_address = 1;
    {PROTOBUF_FIELD_OFFSET(Connection, _impl_.local_address_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .trace2.Address remote_address = 2;
    {PROTOBUF_FIELD_OFFSET(Connection, _impl_.remote_address_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::trace2::Address>()},
    {::_pbi::TcParser::GetTable<::trace2::Address>()},
  }}, {{
  }},
};

::uint8_t* Connection::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:trace2.Connection)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .trace2.Address local_address = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::local_address(this),
        _Internal::local_address(this).GetCachedSize(), target, stream);
  }

  // .trace2.Address remote_address = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::remote_address(this),
        _Internal::remote_address(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trace2.Connection)
  return target;
}

::size_t Connection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trace2.Connection)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .trace2.Address local_address = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.local_address_);
    }

    // .trace2.Address remote_address = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.remote_address_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Connection::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    Connection::MergeImpl
};
const ::google::protobuf::Message::ClassData*Connection::GetClassData() const { return &_class_data_; }


void Connection::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Connection*>(&to_msg);
  auto& from = static_cast<const Connection&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:trace2.Connection)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_local_address()->::trace2::Address::MergeFrom(
          from._internal_local_address());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_remote_address()->::trace2::Address::MergeFrom(
          from._internal_remote_address());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Connection::CopyFrom(const Connection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trace2.Connection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Connection::IsInitialized() const {
  return true;
}

void Connection::InternalSwap(Connection* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Connection, _impl_.remote_address_)
      + sizeof(Connection::_impl_.remote_address_)
      - PROTOBUF_FIELD_OFFSET(Connection, _impl_.local_address_)>(
          reinterpret_cast<char*>(&_impl_.local_address_),
          reinterpret_cast<char*>(&other->_impl_.local_address_));
}

::google::protobuf::Metadata Connection::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_trace2_2eproto_getter, &descriptor_table_trace2_2eproto_once,
      file_level_metadata_trace2_2eproto[5]);
}
// ===================================================================

class Timestamp::_Internal {
 public:
};

Timestamp::Timestamp(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:trace2.Timestamp)
}
Timestamp::Timestamp(const Timestamp& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:trace2.Timestamp)
}
inline void Timestamp::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.seconds_){::int64_t{0}},
      decltype(_impl_.nanos_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
Timestamp::~Timestamp() {
  // @@protoc_insertion_point(destructor:trace2.Timestamp)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Timestamp::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void Timestamp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void Timestamp::Clear() {
// @@protoc_insertion_point(message_clear_start:trace2.Timestamp)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.seconds_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.nanos_) -
      reinterpret_cast<char*>(&_impl_.seconds_)) + sizeof(_impl_.nanos_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Timestamp::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> Timestamp::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_Timestamp_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // int32 nanos = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Timestamp, _impl_.nanos_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(Timestamp, _impl_.nanos_)}},
    // int64 seconds = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(Timestamp, _impl_.seconds_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(Timestamp, _impl_.seconds_)}},
  }}, {{
    65535, 65535
  }}, {{
    // int64 seconds = 1;
    {PROTOBUF_FIELD_OFFSET(Timestamp, _impl_.seconds_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt64)},
    // int32 nanos = 2;
    {PROTOBUF_FIELD_OFFSET(Timestamp, _impl_.nanos_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* Timestamp::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:trace2.Timestamp)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // int64 seconds = 1;
  if (this->_internal_seconds() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_seconds(), target);
  }

  // int32 nanos = 2;
  if (this->_internal_nanos() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<2>(
            stream, this->_internal_nanos(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trace2.Timestamp)
  return target;
}

::size_t Timestamp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trace2.Timestamp)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 seconds = 1;
  if (this->_internal_seconds() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_seconds());
  }

  // int32 nanos = 2;
  if (this->_internal_nanos() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_nanos());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Timestamp::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    Timestamp::MergeImpl
};
const ::google::protobuf::Message::ClassData*Timestamp::GetClassData() const { return &_class_data_; }


void Timestamp::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Timestamp*>(&to_msg);
  auto& from = static_cast<const Timestamp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:trace2.Timestamp)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_seconds() != 0) {
    _this->_internal_set_seconds(from._internal_seconds());
  }
  if (from._internal_nanos() != 0) {
    _this->_internal_set_nanos(from._internal_nanos());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Timestamp::CopyFrom(const Timestamp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trace2.Timestamp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Timestamp::IsInitialized() const {
  return true;
}

void Timestamp::InternalSwap(Timestamp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Timestamp, _impl_.nanos_)
      + sizeof(Timestamp::_impl_.nanos_)
      - PROTOBUF_FIELD_OFFSET(Timestamp, _impl_.seconds_)>(
          reinterpret_cast<char*>(&_impl_.seconds_),
          reinterpret_cast<char*>(&other->_impl_.seconds_));
}

::google::protobuf::Metadata Timestamp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_trace2_2eproto_getter, &descriptor_table_trace2_2eproto_once,
      file_level_metadata_trace2_2eproto[6]);
}
// ===================================================================

class SocketEvent_Read::_Internal {
 public:
  using HasBits = decltype(std::declval<SocketEvent_Read>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SocketEvent_Read, _impl_._has_bits_);
  static const ::trace2::Body& data(const SocketEvent_Read* msg);
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::trace2::Body& SocketEvent_Read::_Internal::data(const SocketEvent_Read* msg) {
  return *msg->_impl_.data_;
}
SocketEvent_Read::SocketEvent_Read(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:trace2.SocketEvent.Read)
}
SocketEvent_Read::SocketEvent_Read(const SocketEvent_Read& from) : ::google::protobuf::Message() {
  SocketEvent_Read* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.data_){nullptr},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.data_ = new ::trace2::Body(*from._impl_.data_);
  }

  // @@protoc_insertion_point(copy_constructor:trace2.SocketEvent.Read)
}
inline void SocketEvent_Read::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.data_){nullptr},
  };
}
SocketEvent_Read::~SocketEvent_Read() {
  // @@protoc_insertion_point(destructor:trace2.SocketEvent.Read)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SocketEvent_Read::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.data_;
}
void SocketEvent_Read::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void SocketEvent_Read::Clear() {
// @@protoc_insertion_point(message_clear_start:trace2.SocketEvent.Read)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.data_ != nullptr);
    _impl_.data_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* SocketEvent_Read::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 1, 0, 2> SocketEvent_Read::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SocketEvent_Read, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_SocketEvent_Read_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // .trace2.Body data = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(SocketEvent_Read, _impl_.data_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .trace2.Body data = 1;
    {PROTOBUF_FIELD_OFFSET(SocketEvent_Read, _impl_.data_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::trace2::Body>()},
  }}, {{
  }},
};

::uint8_t* SocketEvent_Read::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:trace2.SocketEvent.Read)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .trace2.Body data = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::data(this),
        _Internal::data(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trace2.SocketEvent.Read)
  return target;
}

::size_t SocketEvent_Read::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trace2.SocketEvent.Read)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .trace2.Body data = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *_impl_.data_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData SocketEvent_Read::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    SocketEvent_Read::MergeImpl
};
const ::google::protobuf::Message::ClassData*SocketEvent_Read::GetClassData() const { return &_class_data_; }


void SocketEvent_Read::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<SocketEvent_Read*>(&to_msg);
  auto& from = static_cast<const SocketEvent_Read&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:trace2.SocketEvent.Read)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_data()->::trace2::Body::MergeFrom(
        from._internal_data());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SocketEvent_Read::CopyFrom(const SocketEvent_Read& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trace2.SocketEvent.Read)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SocketEvent_Read::IsInitialized() const {
  return true;
}

void SocketEvent_Read::InternalSwap(SocketEvent_Read* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.data_, other->_impl_.data_);
}

::google::protobuf::Metadata SocketEvent_Read::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_trace2_2eproto_getter, &descriptor_table_trace2_2eproto_once,
      file_level_metadata_trace2_2eproto[7]);
}
// ===================================================================

class SocketEvent_Write::_Internal {
 public:
  using HasBits = decltype(std::declval<SocketEvent_Write>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SocketEvent_Write, _impl_._has_bits_);
  static const ::trace2::Body& data(const SocketEvent_Write* msg);
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::trace2::Body& SocketEvent_Write::_Internal::data(const SocketEvent_Write* msg) {
  return *msg->_impl_.data_;
}
SocketEvent_Write::SocketEvent_Write(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:trace2.SocketEvent.Write)
}
SocketEvent_Write::SocketEvent_Write(const SocketEvent_Write& from) : ::google::protobuf::Message() {
  SocketEvent_Write* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.data_){nullptr},
      decltype(_impl_.end_stream_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.data_ = new ::trace2::Body(*from._impl_.data_);
  }
  _this->_impl_.end_stream_ = from._impl_.end_stream_;

  // @@protoc_insertion_point(copy_constructor:trace2.SocketEvent.Write)
}
inline void SocketEvent_Write::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.data_){nullptr},
      decltype(_impl_.end_stream_){false},
  };
}
SocketEvent_Write::~SocketEvent_Write() {
  // @@protoc_insertion_point(destructor:trace2.SocketEvent.Write)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SocketEvent_Write::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.data_;
}
void SocketEvent_Write::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void SocketEvent_Write::Clear() {
// @@protoc_insertion_point(message_clear_start:trace2.SocketEvent.Write)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.data_ != nullptr);
    _impl_.data_->Clear();
  }
  _impl_.end_stream_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* SocketEvent_Write::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 0, 2> SocketEvent_Write::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SocketEvent_Write, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_SocketEvent_Write_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // bool end_stream = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(SocketEvent_Write, _impl_.end_stream_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(SocketEvent_Write, _impl_.end_stream_)}},
    // .trace2.Body data = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(SocketEvent_Write, _impl_.data_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .trace2.Body data = 1;
    {PROTOBUF_FIELD_OFFSET(SocketEvent_Write, _impl_.data_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // bool end_stream = 2;
    {PROTOBUF_FIELD_OFFSET(SocketEvent_Write, _impl_.end_stream_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
  }}, {{
    {::_pbi::TcParser::GetTable<::trace2::Body>()},
  }}, {{
  }},
};

::uint8_t* SocketEvent_Write::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:trace2.SocketEvent.Write)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .trace2.Body data = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::data(this),
        _Internal::data(this).GetCachedSize(), target, stream);
  }

  // bool end_stream = 2;
  if (this->_internal_end_stream() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_end_stream(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trace2.SocketEvent.Write)
  return target;
}

::size_t SocketEvent_Write::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trace2.SocketEvent.Write)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .trace2.Body data = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *_impl_.data_);
  }

  // bool end_stream = 2;
  if (this->_internal_end_stream() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData SocketEvent_Write::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    SocketEvent_Write::MergeImpl
};
const ::google::protobuf::Message::ClassData*SocketEvent_Write::GetClassData() const { return &_class_data_; }


void SocketEvent_Write::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<SocketEvent_Write*>(&to_msg);
  auto& from = static_cast<const SocketEvent_Write&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:trace2.SocketEvent.Write)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_data()->::trace2::Body::MergeFrom(
        from._internal_data());
  }
  if (from._internal_end_stream() != 0) {
    _this->_internal_set_end_stream(from._internal_end_stream());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SocketEvent_Write::CopyFrom(const SocketEvent_Write& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trace2.SocketEvent.Write)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SocketEvent_Write::IsInitialized() const {
  return true;
}

void SocketEvent_Write::InternalSwap(SocketEvent_Write* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SocketEvent_Write, _impl_.end_stream_)
      + sizeof(SocketEvent_Write::_impl_.end_stream_)
      - PROTOBUF_FIELD_OFFSET(SocketEvent_Write, _impl_.data_)>(
          reinterpret_cast<char*>(&_impl_.data_),
          reinterpret_cast<char*>(&other->_impl_.data_));
}

::google::protobuf::Metadata SocketEvent_Write::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_trace2_2eproto_getter, &descriptor_table_trace2_2eproto_once,
      file_level_metadata_trace2_2eproto[8]);
}
// ===================================================================

class SocketEvent_Closed::_Internal {
 public:
};

SocketEvent_Closed::SocketEvent_Closed(::google::protobuf::Arena* arena)
    : ::google::protobuf::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:trace2.SocketEvent.Closed)
}
SocketEvent_Closed::SocketEvent_Closed(const SocketEvent_Closed& from) : ::google::protobuf::internal::ZeroFieldsBase() {
  SocketEvent_Closed* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);

  // @@protoc_insertion_point(copy_constructor:trace2.SocketEvent.Closed)
}




const ::google::protobuf::Message::ClassData SocketEvent_Closed::_class_data_ = {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl,
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl,
};
const ::google::protobuf::Message::ClassData*SocketEvent_Closed::GetClassData() const { return &_class_data_; }







::google::protobuf::Metadata SocketEvent_Closed::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_trace2_2eproto_getter, &descriptor_table_trace2_2eproto_once,
      file_level_metadata_trace2_2eproto[9]);
}
// ===================================================================

class SocketEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SocketEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SocketEvent, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::trace2::SocketEvent, _impl_._oneof_case_);
  static const ::trace2::Timestamp& timestamp(const SocketEvent* msg);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::trace2::SocketEvent_Read& read(const SocketEvent* msg);
  static const ::trace2::SocketEvent_Write& write(const SocketEvent* msg);
  static const ::trace2::SocketEvent_Closed& closed(const SocketEvent* msg);
  static const ::trace2::Connection& connection_per_event(const SocketEvent* msg);
  static void set_has_connection_per_event(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::trace2::Timestamp& SocketEvent::_Internal::timestamp(const SocketEvent* msg) {
  return *msg->_impl_.timestamp_;
}
const ::trace2::SocketEvent_Read& SocketEvent::_Internal::read(const SocketEvent* msg) {
  return *msg->_impl_.event_selector_.read_;
}
const ::trace2::SocketEvent_Write& SocketEvent::_Internal::write(const SocketEvent* msg) {
  return *msg->_impl_.event_selector_.write_;
}
const ::trace2::SocketEvent_Closed& SocketEvent::_Internal::closed(const SocketEvent* msg) {
  return *msg->_impl_.event_selector_.closed_;
}
const ::trace2::Connection& SocketEvent::_Internal::connection_per_event(const SocketEvent* msg) {
  return *msg->_impl_.connection_per_event_;
}
void SocketEvent::set_allocated_read(::trace2::SocketEvent_Read* read) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_event_selector();
  if (read) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(read);
    if (message_arena != submessage_arena) {
      read = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, read, submessage_arena);
    }
    set_has_read();
    _impl_.event_selector_.read_ = read;
  }
  // @@protoc_insertion_point(field_set_allocated:trace2.SocketEvent.read)
}
void SocketEvent::set_allocated_write(::trace2::SocketEvent_Write* write) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_event_selector();
  if (write) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(write);
    if (message_arena != submessage_arena) {
      write = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, write, submessage_arena);
    }
    set_has_write();
    _impl_.event_selector_.write_ = write;
  }
  // @@protoc_insertion_point(field_set_allocated:trace2.SocketEvent.write)
}
void SocketEvent::set_allocated_closed(::trace2::SocketEvent_Closed* closed) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_event_selector();
  if (closed) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(closed);
    if (message_arena != submessage_arena) {
      closed = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, closed, submessage_arena);
    }
    set_has_closed();
    _impl_.event_selector_.closed_ = closed;
  }
  // @@protoc_insertion_point(field_set_allocated:trace2.SocketEvent.closed)
}
SocketEvent::SocketEvent(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:trace2.SocketEvent)
}
SocketEvent::SocketEvent(const SocketEvent& from) : ::google::protobuf::Message() {
  SocketEvent* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.timestamp_){nullptr},
      decltype(_impl_.connection_per_event_){nullptr},
      decltype(_impl_.event_selector_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.timestamp_ = new ::trace2::Timestamp(*from._impl_.timestamp_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.connection_per_event_ = new ::trace2::Connection(*from._impl_.connection_per_event_);
  }
  clear_has_event_selector();
  switch (from.event_selector_case()) {
    case kRead: {
      _this->_internal_mutable_read()->::trace2::SocketEvent_Read::MergeFrom(
          from._internal_read());
      break;
    }
    case kWrite: {
      _this->_internal_mutable_write()->::trace2::SocketEvent_Write::MergeFrom(
          from._internal_write());
      break;
    }
    case kClosed: {
      _this->_internal_mutable_closed()->::trace2::SocketEvent_Closed::MergeFrom(
          from._internal_closed());
      break;
    }
    case EVENT_SELECTOR_NOT_SET: {
      break;
    }
  }

  // @@protoc_insertion_point(copy_constructor:trace2.SocketEvent)
}
inline void SocketEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.timestamp_){nullptr},
      decltype(_impl_.connection_per_event_){nullptr},
      decltype(_impl_.event_selector_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  clear_has_event_selector();
}
SocketEvent::~SocketEvent() {
  // @@protoc_insertion_point(destructor:trace2.SocketEvent)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SocketEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.timestamp_;
  if (this != internal_default_instance()) delete _impl_.connection_per_event_;
  if (has_event_selector()) {
    clear_event_selector();
  }
}
void SocketEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SocketEvent::clear_event_selector() {
// @@protoc_insertion_point(one_of_clear_start:trace2.SocketEvent)
  switch (event_selector_case()) {
    case kRead: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.event_selector_.read_;
      }
      break;
    }
    case kWrite: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.event_selector_.write_;
      }
      break;
    }
    case kClosed: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.event_selector_.closed_;
      }
      break;
    }
    case EVENT_SELECTOR_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = EVENT_SELECTOR_NOT_SET;
}


PROTOBUF_NOINLINE void SocketEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:trace2.SocketEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.timestamp_ != nullptr);
      _impl_.timestamp_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.connection_per_event_ != nullptr);
      _impl_.connection_per_event_->Clear();
    }
  }
  clear_event_selector();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* SocketEvent::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 5, 0, 2> SocketEvent::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SocketEvent, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    5,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_SocketEvent_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .trace2.Timestamp timestamp = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(SocketEvent, _impl_.timestamp_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // .trace2.Connection connection_per_event = 5;
    {::_pbi::TcParser::FastMtS1,
     {42, 1, 4, PROTOBUF_FIELD_OFFSET(SocketEvent, _impl_.connection_per_event_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // .trace2.Timestamp timestamp = 1;
    {PROTOBUF_FIELD_OFFSET(SocketEvent, _impl_.timestamp_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .trace2.SocketEvent.Read read = 2;
    {PROTOBUF_FIELD_OFFSET(SocketEvent, _impl_.event_selector_.read_), _Internal::kOneofCaseOffset + 0, 1,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .trace2.SocketEvent.Write write = 3;
    {PROTOBUF_FIELD_OFFSET(SocketEvent, _impl_.event_selector_.write_), _Internal::kOneofCaseOffset + 0, 2,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .trace2.SocketEvent.Closed closed = 4;
    {PROTOBUF_FIELD_OFFSET(SocketEvent, _impl_.event_selector_.closed_), _Internal::kOneofCaseOffset + 0, 3,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvDefault)},
    // .trace2.Connection connection_per_event = 5;
    {PROTOBUF_FIELD_OFFSET(SocketEvent, _impl_.connection_per_event_), _Internal::kHasBitsOffset + 1, 4,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::trace2::Timestamp>()},
    {::_pbi::TcParser::GetTable<::trace2::SocketEvent_Read>()},
    {::_pbi::TcParser::GetTable<::trace2::SocketEvent_Write>()},
    {::_pbi::FieldAuxDefaultMessage{}, &::trace2::_SocketEvent_Closed_default_instance_},
    {::_pbi::TcParser::GetTable<::trace2::Connection>()},
  }}, {{
  }},
};

::uint8_t* SocketEvent::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:trace2.SocketEvent)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .trace2.Timestamp timestamp = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::timestamp(this),
        _Internal::timestamp(this).GetCachedSize(), target, stream);
  }

  switch (event_selector_case()) {
    case kRead: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::read(this),
          _Internal::read(this).GetCachedSize(), target, stream);
      break;
    }
    case kWrite: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::write(this),
          _Internal::write(this).GetCachedSize(), target, stream);
      break;
    }
    case kClosed: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::closed(this),
          _Internal::closed(this).GetCachedSize(), target, stream);
      break;
    }
    default:
      break;
  }
  // .trace2.Connection connection_per_event = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::connection_per_event(this),
        _Internal::connection_per_event(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trace2.SocketEvent)
  return target;
}

::size_t SocketEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trace2.SocketEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .trace2.Timestamp timestamp = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.timestamp_);
    }

    // .trace2.Connection connection_per_event = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.connection_per_event_);
    }

  }
  switch (event_selector_case()) {
    // .trace2.SocketEvent.Read read = 2;
    case kRead: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.event_selector_.read_);
      break;
    }
    // .trace2.SocketEvent.Write write = 3;
    case kWrite: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.event_selector_.write_);
      break;
    }
    // .trace2.SocketEvent.Closed closed = 4;
    case kClosed: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.event_selector_.closed_);
      break;
    }
    case EVENT_SELECTOR_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData SocketEvent::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    SocketEvent::MergeImpl
};
const ::google::protobuf::Message::ClassData*SocketEvent::GetClassData() const { return &_class_data_; }


void SocketEvent::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<SocketEvent*>(&to_msg);
  auto& from = static_cast<const SocketEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:trace2.SocketEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_timestamp()->::trace2::Timestamp::MergeFrom(
          from._internal_timestamp());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_connection_per_event()->::trace2::Connection::MergeFrom(
          from._internal_connection_per_event());
    }
  }
  switch (from.event_selector_case()) {
    case kRead: {
      _this->_internal_mutable_read()->::trace2::SocketEvent_Read::MergeFrom(
          from._internal_read());
      break;
    }
    case kWrite: {
      _this->_internal_mutable_write()->::trace2::SocketEvent_Write::MergeFrom(
          from._internal_write());
      break;
    }
    case kClosed: {
      _this->_internal_mutable_closed()->::trace2::SocketEvent_Closed::MergeFrom(
          from._internal_closed());
      break;
    }
    case EVENT_SELECTOR_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SocketEvent::CopyFrom(const SocketEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trace2.SocketEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SocketEvent::IsInitialized() const {
  return true;
}

void SocketEvent::InternalSwap(SocketEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SocketEvent, _impl_.connection_per_event_)
      + sizeof(SocketEvent::_impl_.connection_per_event_)
      - PROTOBUF_FIELD_OFFSET(SocketEvent, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
  swap(_impl_.event_selector_, other->_impl_.event_selector_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata SocketEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_trace2_2eproto_getter, &descriptor_table_trace2_2eproto_once,
      file_level_metadata_trace2_2eproto[10]);
}
// ===================================================================

class SocketBufferedTrace::_Internal {
 public:
  using HasBits = decltype(std::declval<SocketBufferedTrace>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SocketBufferedTrace, _impl_._has_bits_);
  static const ::trace2::Connection& connection(const SocketBufferedTrace* msg);
  static void set_has_connection(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::trace2::Connection& SocketBufferedTrace::_Internal::connection(const SocketBufferedTrace* msg) {
  return *msg->_impl_.connection_;
}
SocketBufferedTrace::SocketBufferedTrace(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:trace2.SocketBufferedTrace)
}
SocketBufferedTrace::SocketBufferedTrace(const SocketBufferedTrace& from) : ::google::protobuf::Message() {
  SocketBufferedTrace* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.events_){from._impl_.events_},
      decltype(_impl_.connection_){nullptr},
      decltype(_impl_.trace_id_){},
      decltype(_impl_.read_truncated_){},
      decltype(_impl_.write_truncated_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.connection_ = new ::trace2::Connection(*from._impl_.connection_);
  }
  ::memcpy(&_impl_.trace_id_, &from._impl_.trace_id_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.write_truncated_) -
    reinterpret_cast<char*>(&_impl_.trace_id_)) + sizeof(_impl_.write_truncated_));

  // @@protoc_insertion_point(copy_constructor:trace2.SocketBufferedTrace)
}
inline void SocketBufferedTrace::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.events_){arena},
      decltype(_impl_.connection_){nullptr},
      decltype(_impl_.trace_id_){::uint64_t{0u}},
      decltype(_impl_.read_truncated_){false},
      decltype(_impl_.write_truncated_){false},
  };
}
SocketBufferedTrace::~SocketBufferedTrace() {
  // @@protoc_insertion_point(destructor:trace2.SocketBufferedTrace)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SocketBufferedTrace::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.events_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.connection_;
}
void SocketBufferedTrace::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void SocketBufferedTrace::Clear() {
// @@protoc_insertion_point(message_clear_start:trace2.SocketBufferedTrace)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_events()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.connection_ != nullptr);
    _impl_.connection_->Clear();
  }
  ::memset(&_impl_.trace_id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.write_truncated_) -
      reinterpret_cast<char*>(&_impl_.trace_id_)) + sizeof(_impl_.write_truncated_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* SocketBufferedTrace::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 2, 0, 2> SocketBufferedTrace::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SocketBufferedTrace, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_SocketBufferedTrace_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // uint64 trace_id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(SocketBufferedTrace, _impl_.trace_id_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(SocketBufferedTrace, _impl_.trace_id_)}},
    // .trace2.Connection connection = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(SocketBufferedTrace, _impl_.connection_)}},
    // repeated .trace2.SocketEvent events = 3;
    {::_pbi::TcParser::FastMtR1,
     {26, 63, 1, PROTOBUF_FIELD_OFFSET(SocketBufferedTrace, _impl_.events_)}},
    // bool read_truncated = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(SocketBufferedTrace, _impl_.read_truncated_), 63>(),
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(SocketBufferedTrace, _impl_.read_truncated_)}},
    // bool write_truncated = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(SocketBufferedTrace, _impl_.write_truncated_), 63>(),
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(SocketBufferedTrace, _impl_.write_truncated_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // uint64 trace_id = 1;
    {PROTOBUF_FIELD_OFFSET(SocketBufferedTrace, _impl_.trace_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt64)},
    // .trace2.Connection connection = 2;
    {PROTOBUF_FIELD_OFFSET(SocketBufferedTrace, _impl_.connection_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .trace2.SocketEvent events = 3;
    {PROTOBUF_FIELD_OFFSET(SocketBufferedTrace, _impl_.events_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // bool read_truncated = 4;
    {PROTOBUF_FIELD_OFFSET(SocketBufferedTrace, _impl_.read_truncated_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool write_truncated = 5;
    {PROTOBUF_FIELD_OFFSET(SocketBufferedTrace, _impl_.write_truncated_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
  }}, {{
    {::_pbi::TcParser::GetTable<::trace2::Connection>()},
    {::_pbi::TcParser::GetTable<::trace2::SocketEvent>()},
  }}, {{
  }},
};

::uint8_t* SocketBufferedTrace::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:trace2.SocketBufferedTrace)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint64 trace_id = 1;
  if (this->_internal_trace_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_trace_id(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .trace2.Connection connection = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::connection(this),
        _Internal::connection(this).GetCachedSize(), target, stream);
  }

  // repeated .trace2.SocketEvent events = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_events_size()); i < n; i++) {
    const auto& repfield = this->_internal_events().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool read_truncated = 4;
  if (this->_internal_read_truncated() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_read_truncated(), target);
  }

  // bool write_truncated = 5;
  if (this->_internal_write_truncated() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_write_truncated(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trace2.SocketBufferedTrace)
  return target;
}

::size_t SocketBufferedTrace::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trace2.SocketBufferedTrace)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .trace2.SocketEvent events = 3;
  total_size += 1UL * this->_internal_events_size();
  for (const auto& msg : this->_internal_events()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // .trace2.Connection connection = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *_impl_.connection_);
  }

  // uint64 trace_id = 1;
  if (this->_internal_trace_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_trace_id());
  }

  // bool read_truncated = 4;
  if (this->_internal_read_truncated() != 0) {
    total_size += 2;
  }

  // bool write_truncated = 5;
  if (this->_internal_write_truncated() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData SocketBufferedTrace::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    SocketBufferedTrace::MergeImpl
};
const ::google::protobuf::Message::ClassData*SocketBufferedTrace::GetClassData() const { return &_class_data_; }


void SocketBufferedTrace::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<SocketBufferedTrace*>(&to_msg);
  auto& from = static_cast<const SocketBufferedTrace&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:trace2.SocketBufferedTrace)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_events()->MergeFrom(from._internal_events());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_connection()->::trace2::Connection::MergeFrom(
        from._internal_connection());
  }
  if (from._internal_trace_id() != 0) {
    _this->_internal_set_trace_id(from._internal_trace_id());
  }
  if (from._internal_read_truncated() != 0) {
    _this->_internal_set_read_truncated(from._internal_read_truncated());
  }
  if (from._internal_write_truncated() != 0) {
    _this->_internal_set_write_truncated(from._internal_write_truncated());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SocketBufferedTrace::CopyFrom(const SocketBufferedTrace& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trace2.SocketBufferedTrace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SocketBufferedTrace::IsInitialized() const {
  return true;
}

void SocketBufferedTrace::InternalSwap(SocketBufferedTrace* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.events_.InternalSwap(&other->_impl_.events_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SocketBufferedTrace, _impl_.write_truncated_)
      + sizeof(SocketBufferedTrace::_impl_.write_truncated_)
      - PROTOBUF_FIELD_OFFSET(SocketBufferedTrace, _impl_.connection_)>(
          reinterpret_cast<char*>(&_impl_.connection_),
          reinterpret_cast<char*>(&other->_impl_.connection_));
}

::google::protobuf::Metadata SocketBufferedTrace::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_trace2_2eproto_getter, &descriptor_table_trace2_2eproto_once,
      file_level_metadata_trace2_2eproto[11]);
}
// ===================================================================

class SocketStreamedTraceSegment::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::trace2::SocketStreamedTraceSegment, _impl_._oneof_case_);
  static const ::trace2::Connection& connection(const SocketStreamedTraceSegment* msg);
  static const ::trace2::SocketEvent& event(const SocketStreamedTraceSegment* msg);
};

const ::trace2::Connection& SocketStreamedTraceSegment::_Internal::connection(const SocketStreamedTraceSegment* msg) {
  return *msg->_impl_.message_piece_.connection_;
}
const ::trace2::SocketEvent& SocketStreamedTraceSegment::_Internal::event(const SocketStreamedTraceSegment* msg) {
  return *msg->_impl_.message_piece_.event_;
}
void SocketStreamedTraceSegment::set_allocated_connection(::trace2::Connection* connection) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_message_piece();
  if (connection) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(connection);
    if (message_arena != submessage_arena) {
      connection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connection, submessage_arena);
    }
    set_has_connection();
    _impl_.message_piece_.connection_ = connection;
  }
  // @@protoc_insertion_point(field_set_allocated:trace2.SocketStreamedTraceSegment.connection)
}
void SocketStreamedTraceSegment::set_allocated_event(::trace2::SocketEvent* event) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_message_piece();
  if (event) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(event);
    if (message_arena != submessage_arena) {
      event = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    set_has_event();
    _impl_.message_piece_.event_ = event;
  }
  // @@protoc_insertion_point(field_set_allocated:trace2.SocketStreamedTraceSegment.event)
}
SocketStreamedTraceSegment::SocketStreamedTraceSegment(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:trace2.SocketStreamedTraceSegment)
}
SocketStreamedTraceSegment::SocketStreamedTraceSegment(const SocketStreamedTraceSegment& from) : ::google::protobuf::Message() {
  SocketStreamedTraceSegment* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.trace_id_){},
      decltype(_impl_.message_piece_){},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _this->_impl_.trace_id_ = from._impl_.trace_id_;
  clear_has_message_piece();
  switch (from.message_piece_case()) {
    case kConnection: {
      _this->_internal_mutable_connection()->::trace2::Connection::MergeFrom(
          from._internal_connection());
      break;
    }
    case kEvent: {
      _this->_internal_mutable_event()->::trace2::SocketEvent::MergeFrom(
          from._internal_event());
      break;
    }
    case MESSAGE_PIECE_NOT_SET: {
      break;
    }
  }

  // @@protoc_insertion_point(copy_constructor:trace2.SocketStreamedTraceSegment)
}
inline void SocketStreamedTraceSegment::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.trace_id_){::uint64_t{0u}},
      decltype(_impl_.message_piece_){},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  clear_has_message_piece();
}
SocketStreamedTraceSegment::~SocketStreamedTraceSegment() {
  // @@protoc_insertion_point(destructor:trace2.SocketStreamedTraceSegment)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SocketStreamedTraceSegment::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_message_piece()) {
    clear_message_piece();
  }
}
void SocketStreamedTraceSegment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SocketStreamedTraceSegment::clear_message_piece() {
// @@protoc_insertion_point(one_of_clear_start:trace2.SocketStreamedTraceSegment)
  switch (message_piece_case()) {
    case kConnection: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_piece_.connection_;
      }
      break;
    }
    case kEvent: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_piece_.event_;
      }
      break;
    }
    case MESSAGE_PIECE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = MESSAGE_PIECE_NOT_SET;
}


PROTOBUF_NOINLINE void SocketStreamedTraceSegment::Clear() {
// @@protoc_insertion_point(message_clear_start:trace2.SocketStreamedTraceSegment)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.trace_id_ = ::uint64_t{0u};
  clear_message_piece();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* SocketStreamedTraceSegment::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 3, 2, 0, 2> SocketStreamedTraceSegment::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_SocketStreamedTraceSegment_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // uint64 trace_id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(SocketStreamedTraceSegment, _impl_.trace_id_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(SocketStreamedTraceSegment, _impl_.trace_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint64 trace_id = 1;
    {PROTOBUF_FIELD_OFFSET(SocketStreamedTraceSegment, _impl_.trace_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt64)},
    // .trace2.Connection connection = 2;
    {PROTOBUF_FIELD_OFFSET(SocketStreamedTraceSegment, _impl_.message_piece_.connection_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .trace2.SocketEvent event = 3;
    {PROTOBUF_FIELD_OFFSET(SocketStreamedTraceSegment, _impl_.message_piece_.event_), _Internal::kOneofCaseOffset + 0, 1,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::trace2::Connection>()},
    {::_pbi::TcParser::GetTable<::trace2::SocketEvent>()},
  }}, {{
  }},
};

::uint8_t* SocketStreamedTraceSegment::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:trace2.SocketStreamedTraceSegment)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint64 trace_id = 1;
  if (this->_internal_trace_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_trace_id(), target);
  }

  switch (message_piece_case()) {
    case kConnection: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::connection(this),
          _Internal::connection(this).GetCachedSize(), target, stream);
      break;
    }
    case kEvent: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::event(this),
          _Internal::event(this).GetCachedSize(), target, stream);
      break;
    }
    default:
      break;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trace2.SocketStreamedTraceSegment)
  return target;
}

::size_t SocketStreamedTraceSegment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trace2.SocketStreamedTraceSegment)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 trace_id = 1;
  if (this->_internal_trace_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_trace_id());
  }

  switch (message_piece_case()) {
    // .trace2.Connection connection = 2;
    case kConnection: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.message_piece_.connection_);
      break;
    }
    // .trace2.SocketEvent event = 3;
    case kEvent: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.message_piece_.event_);
      break;
    }
    case MESSAGE_PIECE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData SocketStreamedTraceSegment::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    SocketStreamedTraceSegment::MergeImpl
};
const ::google::protobuf::Message::ClassData*SocketStreamedTraceSegment::GetClassData() const { return &_class_data_; }


void SocketStreamedTraceSegment::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<SocketStreamedTraceSegment*>(&to_msg);
  auto& from = static_cast<const SocketStreamedTraceSegment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:trace2.SocketStreamedTraceSegment)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_trace_id() != 0) {
    _this->_internal_set_trace_id(from._internal_trace_id());
  }
  switch (from.message_piece_case()) {
    case kConnection: {
      _this->_internal_mutable_connection()->::trace2::Connection::MergeFrom(
          from._internal_connection());
      break;
    }
    case kEvent: {
      _this->_internal_mutable_event()->::trace2::SocketEvent::MergeFrom(
          from._internal_event());
      break;
    }
    case MESSAGE_PIECE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SocketStreamedTraceSegment::CopyFrom(const SocketStreamedTraceSegment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trace2.SocketStreamedTraceSegment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SocketStreamedTraceSegment::IsInitialized() const {
  return true;
}

void SocketStreamedTraceSegment::InternalSwap(SocketStreamedTraceSegment* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
        swap(_impl_.trace_id_, other->_impl_.trace_id_);
  swap(_impl_.message_piece_, other->_impl_.message_piece_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata SocketStreamedTraceSegment::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_trace2_2eproto_getter, &descriptor_table_trace2_2eproto_once,
      file_level_metadata_trace2_2eproto[12]);
}
// ===================================================================

class TraceWrapper::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::trace2::TraceWrapper, _impl_._oneof_case_);
  static const ::trace2::SocketBufferedTrace& socket_buffered_trace(const TraceWrapper* msg);
  static const ::trace2::SocketStreamedTraceSegment& socket_streamed_trace_segment(const TraceWrapper* msg);
};

const ::trace2::SocketBufferedTrace& TraceWrapper::_Internal::socket_buffered_trace(const TraceWrapper* msg) {
  return *msg->_impl_.trace_.socket_buffered_trace_;
}
const ::trace2::SocketStreamedTraceSegment& TraceWrapper::_Internal::socket_streamed_trace_segment(const TraceWrapper* msg) {
  return *msg->_impl_.trace_.socket_streamed_trace_segment_;
}
void TraceWrapper::set_allocated_socket_buffered_trace(::trace2::SocketBufferedTrace* socket_buffered_trace) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_trace();
  if (socket_buffered_trace) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(socket_buffered_trace);
    if (message_arena != submessage_arena) {
      socket_buffered_trace = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, socket_buffered_trace, submessage_arena);
    }
    set_has_socket_buffered_trace();
    _impl_.trace_.socket_buffered_trace_ = socket_buffered_trace;
  }
  // @@protoc_insertion_point(field_set_allocated:trace2.TraceWrapper.socket_buffered_trace)
}
void TraceWrapper::set_allocated_socket_streamed_trace_segment(::trace2::SocketStreamedTraceSegment* socket_streamed_trace_segment) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_trace();
  if (socket_streamed_trace_segment) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(socket_streamed_trace_segment);
    if (message_arena != submessage_arena) {
      socket_streamed_trace_segment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, socket_streamed_trace_segment, submessage_arena);
    }
    set_has_socket_streamed_trace_segment();
    _impl_.trace_.socket_streamed_trace_segment_ = socket_streamed_trace_segment;
  }
  // @@protoc_insertion_point(field_set_allocated:trace2.TraceWrapper.socket_streamed_trace_segment)
}
TraceWrapper::TraceWrapper(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:trace2.TraceWrapper)
}
TraceWrapper::TraceWrapper(const TraceWrapper& from) : ::google::protobuf::Message() {
  TraceWrapper* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.trace_){},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  clear_has_trace();
  switch (from.trace_case()) {
    case kSocketBufferedTrace: {
      _this->_internal_mutable_socket_buffered_trace()->::trace2::SocketBufferedTrace::MergeFrom(
          from._internal_socket_buffered_trace());
      break;
    }
    case kSocketStreamedTraceSegment: {
      _this->_internal_mutable_socket_streamed_trace_segment()->::trace2::SocketStreamedTraceSegment::MergeFrom(
          from._internal_socket_streamed_trace_segment());
      break;
    }
    case TRACE_NOT_SET: {
      break;
    }
  }

  // @@protoc_insertion_point(copy_constructor:trace2.TraceWrapper)
}
inline void TraceWrapper::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.trace_){},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  clear_has_trace();
}
TraceWrapper::~TraceWrapper() {
  // @@protoc_insertion_point(destructor:trace2.TraceWrapper)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void TraceWrapper::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_trace()) {
    clear_trace();
  }
}
void TraceWrapper::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TraceWrapper::clear_trace() {
// @@protoc_insertion_point(one_of_clear_start:trace2.TraceWrapper)
  switch (trace_case()) {
    case kSocketBufferedTrace: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.trace_.socket_buffered_trace_;
      }
      break;
    }
    case kSocketStreamedTraceSegment: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.trace_.socket_streamed_trace_segment_;
      }
      break;
    }
    case TRACE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = TRACE_NOT_SET;
}


PROTOBUF_NOINLINE void TraceWrapper::Clear() {
// @@protoc_insertion_point(message_clear_start:trace2.TraceWrapper)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_trace();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* TraceWrapper::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 2, 2, 0, 2> TraceWrapper::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    4, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967283,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_TraceWrapper_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // .trace2.SocketBufferedTrace socket_buffered_trace = 3;
    {PROTOBUF_FIELD_OFFSET(TraceWrapper, _impl_.trace_.socket_buffered_trace_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .trace2.SocketStreamedTraceSegment socket_streamed_trace_segment = 4;
    {PROTOBUF_FIELD_OFFSET(TraceWrapper, _impl_.trace_.socket_streamed_trace_segment_), _Internal::kOneofCaseOffset + 0, 1,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::trace2::SocketBufferedTrace>()},
    {::_pbi::TcParser::GetTable<::trace2::SocketStreamedTraceSegment>()},
  }}, {{
  }},
};

::uint8_t* TraceWrapper::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:trace2.TraceWrapper)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  switch (trace_case()) {
    case kSocketBufferedTrace: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::socket_buffered_trace(this),
          _Internal::socket_buffered_trace(this).GetCachedSize(), target, stream);
      break;
    }
    case kSocketStreamedTraceSegment: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::socket_streamed_trace_segment(this),
          _Internal::socket_streamed_trace_segment(this).GetCachedSize(), target, stream);
      break;
    }
    default:
      break;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trace2.TraceWrapper)
  return target;
}

::size_t TraceWrapper::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trace2.TraceWrapper)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (trace_case()) {
    // .trace2.SocketBufferedTrace socket_buffered_trace = 3;
    case kSocketBufferedTrace: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.trace_.socket_buffered_trace_);
      break;
    }
    // .trace2.SocketStreamedTraceSegment socket_streamed_trace_segment = 4;
    case kSocketStreamedTraceSegment: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.trace_.socket_streamed_trace_segment_);
      break;
    }
    case TRACE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData TraceWrapper::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    TraceWrapper::MergeImpl
};
const ::google::protobuf::Message::ClassData*TraceWrapper::GetClassData() const { return &_class_data_; }


void TraceWrapper::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<TraceWrapper*>(&to_msg);
  auto& from = static_cast<const TraceWrapper&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:trace2.TraceWrapper)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.trace_case()) {
    case kSocketBufferedTrace: {
      _this->_internal_mutable_socket_buffered_trace()->::trace2::SocketBufferedTrace::MergeFrom(
          from._internal_socket_buffered_trace());
      break;
    }
    case kSocketStreamedTraceSegment: {
      _this->_internal_mutable_socket_streamed_trace_segment()->::trace2::SocketStreamedTraceSegment::MergeFrom(
          from._internal_socket_streamed_trace_segment());
      break;
    }
    case TRACE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void TraceWrapper::CopyFrom(const TraceWrapper& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trace2.TraceWrapper)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool TraceWrapper::IsInitialized() const {
  return true;
}

void TraceWrapper::InternalSwap(TraceWrapper* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.trace_, other->_impl_.trace_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata TraceWrapper::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_trace2_2eproto_getter, &descriptor_table_trace2_2eproto_once,
      file_level_metadata_trace2_2eproto[13]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace trace2
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
